> 从 URL 在浏览器被被输入到页面展现的过程中发生了什么，大多数回答都是说请求响应之后 DOM 怎么被构建，被绘制出来。但是你有没有想过，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？

**我们也看一下下面这几个问题。**

1. 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？
2. 一个 TCP 连接可以对应几个 HTTP 请求？
3. 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？
4. 为什么有的时候刷新页面不需要重新建立 SSL 连接？
5. 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？



> 先来看看第一个问题：`现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？`

在HTTP/1.0里面，一个服务器在发送完一个HTTP响应后，会断开TCP链接。但是这样每次请求都会重新建立和断开TCP链接，代价过大。所以虽然标准中没有设定，但是某些服务器对 Connection: keep-alive 的 Header 进行了支持。

意思是说，完成这个 HTTP 请求之后，`不要断开 HTTP 请求使用的 TCP 连接`。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免，两张图片是我短时间内两次访问 github.com 的时间统计：



![image-20201119161306596](https://raw.githubusercontent.com/tanhrepo/img/master/img/image-20201119161306596.png)

![image-20201119161347417](https://raw.githubusercontent.com/tanhrepo/img/master/img/image-20201119161347417.png)

可以看到头一次访问，有初始化连接和 SSL 开销；第二次访问的时候，初始化连接和SLL开销消失了，说明是使用的同一个TCP连接。

持久连接：既然维持 TCP 连接好处这么多，`HTTP/1.1` 就把 `Connection` 头写进标准，并且默认开启持久连接，除非请求中写明 `Connection: close`，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。

> 所以第一个问题的答案是：默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 `Connection: close` 才会在请求完成后关闭连接。

> **第二个问题：一个 TCP 连接可以对应几个 HTTP 请求？**

了解了第一个问题之后，其实这个问题已经有了答案，如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。

> **第三个问题：一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？**

HTTP/1.1存在一个问题，单个TCP连接在`同一时刻只能处理一个请求`，意思就是说：`两个请求的生命周期不能重叠`，任意两个HTTP请求从开始到结束的时间在同一个TCP连接里面不能重叠。

虽然HTTP/1.1规范中规定了Pipelining来试图解决这个问题，但是这个功能在浏览器中`默认是关闭`的。

`Pipelining`：RFC 2616中规定了：

一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。

这个标准这么设定的原因大概是：由于HTTP/1.1是一个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以`顺序必须一致`。比如你向服务器发送了两个请求GET/query?q=A和GET/query?q=B,服务器返回了两个结果，浏览器没有办法根据响应的结果来判断响应对应于哪一个请求的。

> **Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题：**

1. 一些代理服务器不能正确的处理 HTTP Pipelining。
2. 正确的流水线实现是复杂的。
3. Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。

所以浏览器默认不开启Pipelining


# 网络

## http和https

### 1. http和https的基本概念

http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。

### 2. http和https的区别？

http传输的数据都是`未加密`的，也就是明文的，网景公司设置了`SSL协议`来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。
主要的区别如下：

Https协议`需要ca证书`，费用较高。

http是超文本传输协议，信息是明文传输，https则是具有安全性的`ssl加密传输协议`。

使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443

http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

### 3. https协议的工作原理

客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

客户使用https url访问服务器，则要求web 服务器建立ssl链接。

web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。

客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。

客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。

web服务器通过自己的私钥解密出会话密钥。

web服务器通过会话密钥加密与客户端之间的通信。

### 4. https协议的优点

使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。

### 5. https协议的缺点

https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。

https缓存不如http高效，会增加数据开销。

SSL证书也需要钱，功能越强大的证书费用越高。

SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。



##  TCP和UDP的区别

1. TCP是面向连接的，udp是无连接的即发送数据前不需要先建立链接。

2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。

3. TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。

4. TCP只能是1对1的，UDP支持1对1,1对多。

5. TCP的首部较大为20字节，而UDP只有8字节。

6. TCP是面向连接的可靠性传输，而UDP是不可靠的。

## WebSocket

### 1. 什么是WebSocket?

WebSocket是HTML5中的协议，支持持久连续，http协议不支持持久性连接。Http1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的keep-alive，将多个http请求合并为1个

### 2. WebSocket是什么样的协议，具体有什么优点？

HTTP的生命周期通过Request来界定，也就是Request一个Response，那么在Http1.0协议中，这次Http请求就结束了。在Http1.1中进行了改进，是的有一个connection：Keep-alive，也就是说，在一个Http连接中，可以发送多个Request，接收多个Response。但是必须记住，在Http中一个Request只能对应有一个Response，而且这个Response是被动的，不能主动发起。

WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。一个websocket握手协议的实现，基本是2个属性，upgrade，connection。



## 说一下http2.0

简要概括：http2.0是基于1999年发布的http1.0之后的首次更新。

提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比http1.0）

允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。

二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码

首部压缩

服务器端推送

##  fetch发送2次请求的原因

> 为什么fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？

答：因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。



## Cookie、sessionStorage、localStorage的区别

* cookie数据始终在同源的http请求中携带(即使不需要)，即cookie在浏览器和服务器间来回传递
* cookie数据还有路径（path）的概念，可以限制。cookie只属于某个路径下
* 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如回话标识。
* webStorage虽然也有存储大小的限制，但是比cookie大得多，可以达到5M或更大
* 数据的有效期不同
  * sessionStorage：仅在当前的浏览器窗口关闭有效；
  * localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；
  * cookie：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭
* 作用域不同
  * sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；
  * localStorage：在所有同源窗口都是共享的；
  * cookie：也是在所有同源窗口中共享的



##  cookie session区别

### 参考回答：

1.  cookie数据存放在客户的浏览器上，session数据放在服务器上。

2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
   考虑到安全应当使用session。

3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
   考虑到减轻服务器性能方面，应当使用COOKIE。

4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

## Doctype作用?严格模式与混杂模式如何区分？它们有何意义?

Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。

严格模式的排版和JS 运作模式是 以该浏览器支持的最高标准运行。

混杂模式，`向后兼容`，模拟老式浏览器，防止浏览器无法兼容页面。



## 介绍知道的http返回的状态码

`100`  Continue  继续。客户端应继续其请求

`101`  Switching Protocols  切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议

`200 ` OK  请求成功。一般用于GET与POST请求

`201`  Created  已创建。成功请求并创建了新的资源

`202`  Accepted  已接受。已经接受请求，但未处理完成

`203`  Non-Authoritative Information  非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本

`204 ` No Content  无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档

`205`  Reset Content  重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域

`206`  Partial Content  部分内容。服务器成功处理了部分GET请求

`300`  Multiple Choices  多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择

`301`  Moved Permanently  永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替

`302`  Found  临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI

`303`  See Other  查看其它地址。与301类似。使用GET和POST请求查看

`304`  Not Modified  未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源

`305`  Use Proxy  使用代理。所请求的资源必须通过代理访问

`306`  Unused  已经被废弃的HTTP状态码

`307`  Temporary Redirect  临时重定向。与302类似。使用GET请求重定向

`400 ` Bad Request  客户端请求的语法错误，服务器无法理解

`401 ` Unauthorized  请求要求用户的身份认证

`402`  Payment Required  保留，将来使用

`403 ` Forbidden  服务器理解请求客户端的请求，但是拒绝执行此请求

`404 ` Not Found  服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面

`405`  Method Not Allowed  客户端请求中的方法被禁止

`406`  Not Acceptable  服务器无法根据客户端请求的内容特性完成请求

`407`  Proxy Authentication Required  请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权

`408`  Request Time-out  服务器等待客户端发送的请求时间过长，超时

`409`  Conflict  服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突

`410 ` Gone  客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置

`411`  Length Required  服务器无法处理客户端发送的不带Content-Length的请求信息

`412`  Precondition Failed  客户端请求信息的先决条件错误

`413`  Request Entity Too Large  由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息

`414`  Request-URI Too Large  请求的URI过长（URI通常为网址），服务器无法处理

`415`  Unsupported Media Type  服务器无法处理请求附带的媒体格式

`416`  Requested range not satisfiable  客户端请求的范围无效

`417`  Expectation Failed  服务器无法满足Expect的请求头信息

`500`  Internal Server Error  服务器内部错误，无法完成请求

`501`  Not Implemented  服务器不支持请求的功能，无法完成请求

`502`  Bad Gateway  作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应

`503`  Service Unavailable  由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中

`504 ` Gateway Time-out  充当网关或代理的服务器，未及时从远端服务器获取请求

`505`  HTTP Version not supported  服务器不支持请求的HTTP协议的版本，无法完成处理



##  强，协商缓存

缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。

|          | 获取资源形式 | 状态码              | 发送请求到服务器                 |
| -------- | ------------ | ------------------- | -------------------------------- |
| 强缓存   | 从缓存取     | 200（from cache）   | 否，直接从缓存取                 |
| 协商缓存 | 从缓存取     | 304（not modified） | 是，通过服务器来告知缓存是否可用 |

强缓存相关字段有expires，cache-control。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。

协商缓存相关字段有Last-Modified/If-Modified-Since，Etag/If-None-Match









































# HTML

## 说一下HTML5 drag api

`dragstart`：事件主体是被拖放元素，在开始拖放被拖放元素时触发。

`darg`：事件主体是被拖放元素，在正在拖放被拖放元素时触发。

`dragenter`：事件主体是目标元素，在被拖放元素进入某元素时触发。

`dragover`：事件主体是目标元素，在被拖放在某元素内移动时触发。

`dragleave`：事件主体是目标元素，在被拖放元素移出目标元素是触发。

`drop`：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。

`dragend`：事件主体是被拖放元素，在整个拖放操作结束时触发

# js

## BOM属性对象方法

### 1. location对象

location.href-- 返回或设置当前文档的URL
location.search -- 返回URL中的查询字符串部分。例如 http://www.dreamdu.com/dreamdu.php?id=5&name=dreamdu 返回包括(?)后面的内容?id=5&name=dreamdu
location.hash -- 返回URL#后面的内容，如果没有#，返回空
location.host -- 返回URL中的域名部分，例如[www.dreamdu.com](http://www.dreamdu.com/)
location.hostname -- 返回URL中的主域名部分，例如dreamdu.com
location.pathname -- 返回URL的域名后的部分。例如 http://www.dreamdu.com/xhtml/ 返回/xhtml/
location.port -- 返回URL中的端口部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回8080
location.protocol -- 返回URL中的协议部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回(//)前面的内容http:
location.assign -- 设置当前文档的URL
location.replace() -- 设置当前文档的URL，并且在history对象的地址列表中移除这个URL location.replace(url);
location.reload() -- 重载当前页面

### 2.history对象

history.go() -- 前进或后退指定的页面数 history.go(num);
history.back() -- 后退一页
history.forward() -- 前进一页

### 3. Navigator对象

navigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)
navigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie

##  1、数组扁平化

```
const arr = [1, [2, [3, [4, 5]]], 6];
```

#### 方法一：flat()
>
> ```js
> const res1 = arr.flat(Infinity);
> console.log('1',res1)
> ```
>
> // ==>> [1, 2, 3, 4, 5, 6]
>
> // ==>> [1, 2, 3, 4, 5, 6]

#### 方法二:利用正则
>
> ```js
> const res2 = JSON.stringify(arr).replace(/\[|\]/g, '').split(',');
> console.log('2',res2)
> ```
>
> // ==>> ["1", "2", "3", "4", "5", "6"],`数据类型都会变成字符串`
>
> // ==>> ["1", "2", "3", "4", "5", "6"],`数据类型都会变成字符串`

#### 方法三:正则改良
>
> ```js
> const res3 = JSON.parse('[' + JSON.stringify(arr).replace(/\[|\]/g, '') + ']');
> console.log('3',res3)
> ```
>
> // ==>> [1, 2, 3, 4, 5, 6]
>
> // ==>> [1, 2, 3, 4, 5, 6]

#### 方法四:使用reduce
>
> ```js
> const flatten = arr => {
> 	return arr.reduce((pre, cur) => {
> 		return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);
> 	}, [])
> }
> const res4 = flatten(arr);
> console.log('4',res4)
> ```
>
> 

#### 方法五:函数递归
>
> ```js
> const res5 = [];
> const fn = arr => {
> 	for (let i = 0, j = arr.length; i < j; i++) {
> 		if (Array.isArray(arr[i])) {
> 			fn(arr[i])
> 		} else {
> 			res5.push(arr[i])
> 		}
> 	}
> 	return res5
> }
> fn(arr)
> console.log('5',res5)
> ```
>
> 



## 2、 数组去重

```
const arr = [1,1,'1',17,true,true,false,false,'true','a',{},{}];
```

```
====> [1,'1',17,true,false,'true','a',{},{}] 
```

#### 方法一:利用set
> ```js
> const res1 = Array.from(new Set(arr));
> console.log("res1:",res1);
> ```

#### 方法二:两层for循环+splice
> ```js
> const unique1 = arr => {
> 	let len = arr.length;
> 	for(let i = 0;i<len;i++){
> 		for(let j = i + 1;j < len;j++){
> 			if (arr[i] === arr[j] ){
> 				arr.splice(j,1);
> 				len--;
> 				j--;
> 			}
> 		}
> 	}
> 	return arr;
> }
> let res2 = unique1(arr)
> console.log("res2:",res2);
> ```

#### 方法三利用indexOf
>
> ```js
> const unique2 = arr =>{
> 	const res = [];
> 	for (let i = 0,j = arr.length;i < j;i++){
> 		if(res.indexOf(arr[i]) === -1) res.push(arr[i]);
> 	}
> 	return res;
> }
> let res3 = unique2(arr)
> console.log("res3:",res3)
> ```
>
> 

#### 方法四:利用include
>
> ```js
> const unique3 = arr =>{
> 	const res = [];
> 	for(let i=0,j = arr.length;i<j;i++){
> 		if(!res.includes(arr[i])) res.push(arr[i]);
> 	}
> 	return res;
> }
> 
> let res4 = unique3(arr)
> console.log("res4:",res4)
> ```
>
> 

#### 方法五：利用filter
> ```js
> const unique4 = arr =>{
> 	return arr.filter((item,index) =>{
> 		return arr.indexOf(item) === index;
> 	});
> }
> let res5 = unique4(arr)
> console.log("res5:",res5)
> ```
>
> 

#### 方法六：利用Map

>
> ```js
> const unique5 = arr =>{
> 	const map = new Map();
> 	const res = [];
> 	for(let i = 0,j = arr.length;i < j; i++){
> 		if(!map.has(arr[i])){
> 			map.set(arr[i],true)
> 			res.push(arr[i]);
> 		}
> 	}
> 	return res;
> }
> let res6 = unique5(arr)
> console.log("res6:",res6)
> ```

## 3、 类数组转化为数组

类数组是具有length属性，但不具有数组原型上的方法

常见的类数组有arguments、DOM操作方法返回的结果

### 方法一: Array.from

```js
Array.from(document.queryselectorAl1 ( 'div ' ))
```

### 方法二:Array.prototype.slice.callo

```js
Array.prototype.slice.call(document.queryselectorAll ( 'div'))
```

### 方法三:扩展运算符
~~~js
[ ...document.querySelectorAll( 'div')]
~~~

### 方法四:利用concat

~~~js
Array.prototype.concat.apply([],document.querySelectorAll( 'div'));
~~~



## 4.什么是函数柯里化？

是把`接受多个参数`的函数变换成`接受一个`单一参数（最初函数的第一个参数）的`函数`，

并且返回(`接受余下的参数而且返回结果的新函数`)的技术。

把接受多个参数的函数转换成接受一个单一参数的函数

```js
// 普通方法
var add = function(x, y) {
    return x + y;
}    
add(3, 4)       //7

// 柯里化
var foo = function(x) {
    return function(y) {
        return x + y
    }
}    
foo(3)(4)       // 7    
```

## 5.什么是Promise对象，有哪些用法

### Promise对象的定义
Promise是异步编程的一种解决方案，它是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise
是一个对象，从它可以获取异步操作的消息。可以用来解决“回调地狱”的问题。Promise 提供统一的
API，各种异步操作都可以用同样的方法进行处理。promise对象是一个构造函数，用来生成Promise实例； 

### Promise对象的特点
1. 对象的状态不受外界影响，promise对象代表一个异步操作，有三种状态，`pending`（进行中）、`fulfilled`（已成功）、`rejected`（已失败）。

   只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来“承诺”；

2. 一旦状态改变就不会再变，任何时候都可以得到这个结果，
3. promise对象的状态改变，只有两种可能：从`pending变为fulfilled`，从`pending变为rejected`。这时就称为`resolved`（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果，这与事件（event）完全不同，事件的特点是：`如果你错过了它，再去监听是得不到结果`的。

有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。

### Promise也有一些缺点。

* 首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。

* 其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。

* 第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

### Promise对象的用法

它是一个构造函数，这个构造函数里有两个参数，分别是：`resolve`（成功之后的回调函数）、`reject`（失败之后的回调函数）。
因为promise表示的是一个异步操作，每当我们new一个promise实例，就表示一个具体的异步操作，那么这个异步操作的结果就只能有两种状态：成功/失败，两者都需要回调函数resolve/reject返回。所以内部拿到操作的结果后，无法使用return把操作结果返回给调用者，这时候只能用回调函数的形式来把成功或失败的结果返回给调用者。

promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数

then方法可以接受连个回调函数作为参数，第一个回调函数是promise对象的状态变为resolved时调用，第二个回调函数是promise对象的状态变为rejected时调用，其中，第二个函数是可选的，不一定要提供，这两个函数都接受promise对象传出的值作为参数；

## 6.什么是REST，用起来有什么好处

REST是一种`设计API的模式`。最常用的数据格式是JSON。由于JSON能直接被JavaScript读取，所以，以JSON格式编写的REST风格的API具有简单、易读、易用的特点。通过REST模式设计的API可以把web
app 全部功能进行封装，可以很容易的实现前后端分离，使的前端代码易编写，后端代码易测试。





# vue

## 1. 介绍MVVM

什么是MVVM？[MVVM](https://en.wikipedia.org/wiki/Model–view–viewmodel)是Model-View-ViewModel的缩写。

我们已经用`MVC`模式通过koa实现了`后端数据`、`模板页面`和`控制器`的分离，但是，对于前端来说，还不够。

>  `MVVM`最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把`Model`用纯`JavaScript对象`表示，`View负责显示`，两者做到了最大限度的分离。
>
> 把Model和View`关联`起来的就是`ViewModel`。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。

MVVM 就是将其中的View 的状态和行为抽象化，让我们将`视图 UI 和业务逻辑分开`。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。

## 2. Vue与Angular以及React的区别

###  1.AngularJS

* 相同点：
  都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。

* 不同点：
  AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。

###  2.React

* 相同点：
  React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。
* 不同点：
  React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。

## 3. Vue的生命周期

- **beforeCreate**
- **created**
- **beforeMount**
- **mounted**
- **beforeUpdate**
- **updated**
- **beforeDestroy**
- **destroyed**

**创建、数据初始化、挂载、更新、销毁**

### 1.什么是vue生命周期？
答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。

### 2.vue生命周期的作用是什么？
答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。

### 3.vue生命周期总共有几个阶段？
答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。

### 4.第一次页面加载会触发哪几个钩子？
答：会触发 下面这几个`beforeCreate`, `created`, `beforeMount`, `mounted `。

### 5.DOM 渲染在 哪个周期中就已经完成？
答：DOM 渲染在 mounted 中就已经完成了。



### 全过程

![](https://gitee.com/thonger/img/raw/master/img/13119812-5890a846b6efa045.png)

## 4. Vue实现数据双向绑定的原理：Object.defineProperty（）

vue实现数据双向绑定主要是：采**用数据劫持结合发布者-订阅者模式**的方式，通过**Object.defineProperty（）**来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 `Object.defineProperty` 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

> vue的数据双向绑定 将`MVVM`作为数据绑定的入口，整合`Observer`，`Compile`和`Watcher`三者，
>
> 1. 通过`Observer`来`监听`自己的`model`的数据变化，
>
> 2. 通过`Compile`来`解析编译模板`指令（vue中是用来解析` {{}}`），
>
> 3. 最终利用`watcher`搭起`observer和Compile`之间的通信桥梁，
>
> 达到数据变化 —>视图更新；
> 视图交互变化（input）—>数据model变更双向绑定效果。

> 可以实现双向绑定的方法
> v-model，{{}}，v-bind，sync 修饰符，vue-better-sync 插件，

## 5. Vue组件间的参数传递

###  1.父组件与子组件传值

父组件传给子组件：子组件通过`props`方法接受数据;
子组件传给父组件：`$emit`方法传递参数

### 2.非父子组件间的数据传递，兄弟组件传值



1. `eventBus`，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比`较小`时，用这个比较合适。

2. `VUEX`，Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。
   1. **state**
      Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。
   2. **mutations**
      mutations定义的方法动态修改Vuex 的 store 中的状态或数据。
   3. **getters**
      类似vue的计算属性，主要用来过滤一些数据。
   4. **action**
      actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。
   5. **modules**
      项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。



## 6. Vue的路由实现：hash模式 和 history模式

### **hash模式：**

在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；
特点：hash虽然在URL中，但`不被包括在HTTP请求中`；用来指导浏览器动作，对服务端安全无用，`hash不会重加载页面`。
hash 模式下，仅 `hash` 符号`之前`的内容会被包含在请求中，如 [http://www.xxx.com](http://www.xxx.com/)，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。

### **history模式：**

history采用HTML5的新特性；且提供了两个新方法：`pushState（）`，`replaceState（）`可以对浏览器`历史记录栈`进行修改，以及`popState`事件的`监听`到`状态变更`。
history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。**Vue-Router 官网里如此描述：**“不过这种模式要玩好，还需要后台配置支持……所以,要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”



## 7. vue路由的钩子函数

首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。

**beforeEach**主要有3个参数to，from，next：

**to**：route即将进入的目标路由对象，

**from**：route当前导航正要离开的路由

**next**：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。

## 8. vue-cli如何新增自定义指令？

### 1.创建局部指令

```js
var app = new Vue({
    el: '#app',
    data: {    
    },
    // 创建指令(可以多个)
    directives: {
        // 指令名称
        dir1: {
            inserted(el) {
                // 指令中第一个参数是当前使用指令的DOM
                console.log(el);
                console.log(arguments);
                // 对DOM进行操作
                el.style.width = '200px';
                el.style.height = '200px';
                el.style.background = '#000';
            }
        }
    }
})
```

### 2.全局指令

```js
Vue.directive('dir2', {
    inserted(el) {
        console.log(el);
    }
})
```

### 3.指令的使用

```html
<div id="app">
    <div v-dir1></div>
    <div v-dir2></div>
</div>
```

##  9. 对keep-alive 的了解

**keep-alive**是 Vue 内置的一个组件，可以使被包含的组件保留状态，或`避免重新渲染`。
在vue 2.1.0 版本之后，keep-alive新加入了两个属性: `include`(包含的组件缓存) 与 `exclude`(排除的组件不缓存，优先级大于include) 

> keep-alive是一个抽象组件：它`自身不会渲染一个DOM元素`，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会`缓存不活动的组件`实例，而不是销毁它们。

> ### 应用场景
>
> 用户在某个列表页面选择筛选条件过滤出一份数据列表，
>
> 由列表页面`进入`数据详情页面，再`返回`该列表页面，
>
> 我们希望：列表页面可以`保留`用户的`筛选（或选中）状态`。
>  keep-alive就是用来解决这种场景。当然keep-alive不仅仅是能够`保存页面/组件的状态`这么简单，它还可以`避免`组件`反复创建和渲染`，有效`提升系统性能`。总的来说，**keep-alive用于保存组件的渲染状态。**

## 10. 零碎知识点

### **1.css只在当前组件起作用**
在style标签中写入**scoped**即可 例如：<style scoped></style>

### **2.v-if 和 v-show 区别**

v-if按照条件是否渲染，v-show是display的block或none；需要频繁切换显示的页面推荐用v-show，速度更快。

### **3.`$route`和`$router`的区别**
`$route`是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而`$router`是“路由实例”对象包括了路由的跳转方法，钩子函数等。

### **4.vue.js的两个核心**

数据驱动、组件系统

### **5.vue常用的修饰符？**

`.prevent`: 提交事件不再重载页面；

`.stop`: 阻止单击事件冒泡；

`.self`: 当事件发生在该元素本身而不是子元素的时候会触发；

`.capture`: 事件侦听，事件发生的时候会调用

### **6.vue等单页面应用及其优缺点**

* 优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。
* 缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。

### **7.怎么定义 vue-router 的动态路由? 怎么获取传过来的值**

在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。


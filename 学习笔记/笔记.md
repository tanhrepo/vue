## 浏览器内核
> Apple的Safari, Google的Chrome, Nokia S60平台的默认浏览器，
Apple手机的默认浏览器，Android手机的默认浏览器均采用的Webkit作为器浏览器内核。  
Webkit的采用程度由此可见一斑，理所当然的成为了当今主流的三大浏览器内核之一。  
另外两个分别是Gecko和Trident，  
大名鼎鼎的Firefox便是使用的Gecko 内核，  
而微软的IE系列则使用的是Trident内核。  
搜狗浏览器是双核的，双核并不是指一个页面由2个内核同时处理,  
而是所有网页（通常是标准通用标记语言的应用超文本标记语言）
由webkit内核处理,只有银行网站用IE内核

>浏览器 的内核引擎，基本上是四分天下：  
>1）Trident: IE 以Trident 作为内核引擎；  
>2) Gecko: Firefox 是基于 Gecko 开发；  
>3）WebKit: Safari, Google Chrome,傲游3,猎豹浏览器,百度浏览器 opera浏览器；  
>4）Presto: Opera的内核，但由于市场选择问题，主要应用在手机平台--Opera mini  

* 注：2013年2月Opera宣布转向WebKit引擎  
* 注：2013年4月Opera宣布放弃WEBKIT，跟随GOOGLE的新开发的blink引擎


## CSS sprites
CSS Sprites整理起来更为方便，同一个按钮不同状态的图片也不需要一个个切割出来并个别命名  
CSS Sprites在国内很多人叫css精灵，是一种网页图片应用处理方式。  
<font color="lightblue">1. 它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。  
2. 利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字精确的定位出背景图片的位置.  
3. 利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能，这也是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因；  
4. CSS Sprites能减少图片的字节，曾经比较过多次3张图片合并成1张图片的字节总是小于这3张图片的字节总和。  
5. 解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。  
6. 更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来更加方便。</font>

> **缺点**  
（1）图片合并麻烦：图片合并时，需要把多张图片有序的合理的合并成一张图片，并留好足够的空间防止版块出现不必要的背景。  
（2）图片适应性差：在高分辨的屏幕下自适应页面，若图片不够宽会出现背景断裂。  
（3）图片定位繁琐：开发时需要通过工具测量计算每个背景单元的精确位置。  
（4）可维护性差：页面背景需要少许改动，可能要修改部分或整张已合并的图片，进而要改动css。在避免改动图片的前提下，又只能（最好）往下追加图片，但这样增加了图片字节。  

<br>

## JavaScript中 call和apply的描述
call()方法和apply()方法的作用相同，他们的区别在于接收参数的方式不同。  
对于call()，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。  
在使用call()方法时，传递给函数的参数必须逐个列举出来。  
使用apply()时，传递给函数的是参数数组）如下代码做出解释：
```
function add(c, d){
	return this.a + this.b + c + d;
}
var o = {a:1, b:3};
add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16
add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34
```

## HTML的Doctype和严格模式与混杂模式
1. \<!DOCTYPE> 声明位于文档中的最前面，处于 \<html> 标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。
2. 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
3. DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现

## javascript常见事件的触发情况
1. 点击事件：  
        1. onclick：单击事件  
        2. ondblclick：双击事件  
2. 焦点事件:  
        1. onblur：失去焦点  
        2. onfocus:元素获得焦点。
3. 加载事件:  
        1. onload：一张页面或一幅图像完成加载。
4. 鼠标事件：  
        1. onmousedown    鼠标按钮被按下。  
        2. onmouseup      鼠标按键被松开。  
        3. onmousemove    鼠标被移动。  
        4. onmouseover    鼠标移到某元素之上。  
        5. onmouseout     鼠标从某元素移开。  
5. 键盘事件：  
        1. onkeydown      某个键盘按键被按下。  
        2. onkeyup        某个键盘按键被松开。  
        3. onkeypress     某个键盘按键被按下并松开。  
6. 选择和改变  
        1. onchange       域的内容被改变。比如当文字值改变时，产生该事件  
        2. onselect       文本被选中。文字加亮后，产生该事件  
7. 表单事件：  
        1. onsubmit       确认按钮被点击。  
        2. onreset    	  重置按钮被点击。  

## isNUN方法
NaN,即非数值（Not a Number）是一个特殊的数值，这个数值用来表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。

针对NaN的特点，ECMAScript定义了isNaN（）函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN（）在接受一个值后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串“10”或Boolean值。  
而任何不能被转换为数值的值都会导致这个函数返回true。

## javascript变量定义规则
第一个字符必须是一个 ASCII 字母（大小写均可），或一个下划线(_)。注意第一个字符不能是数字。   
后续的字符必须是字母、数字或下划线。   
变量名称一定不能是 保留字。 

## 下面这个JS程序的输出是什么：
```
function Foo() {
    var i = 0;
    return function() {
        console.log(i++);
    }
}

var f1 = Foo(),
    f2 = Foo();
f1();//0
f1();//1
f2();//0

```
这道题考察闭包和引用类型对象的知识点：  
1.一般来说函数执行完后它的局部变量就会随着函数调用结束被销毁，但是此题foo函数返回了一个匿名函数的引用（即一个闭包），它可以访问到foo()被调用产生的环境，而局部变量i一直处在这个环境中，只要一个环境有可能被访问到，它就不会被销毁，所以说闭包有延续变量作用域的功能。这就好理解为什么：
```
f1();//0
f1();//1

```
2.我一开始认为f1和f2都=foo()是都指向了同一个function引用类型，所以顺理成章就会答错认为：
```
f2();//2
```
但其实foo()返回的是一个匿名函数，所以f1,f2相当于指向了两个不同的函数对象，所以结果也就顺理成章的变为：
```
f2();//0
```

## 浏览器中使用js跨域获取数据
>只要 协议 、域名 、端口 有任何一个 不同, 都被当作是 不同 的域。  
完全一致的意思是，域名要相同（ www.example.com 和example.com 不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。  
有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。
1. CORS  
CORS（Corss-Origin Resource Sharing,跨资源共享），基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应的成功或失败。即给请求附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部决定是否给予响应。  
2. document.domain  
将页面的document.domain设置为相同的值，页面间可以互相访问对方的JavaScript对象。  
注意：
不能将值设置为URL中不包含的域；  
松散的域名不能再设置为紧绷的域名。   
3. 图像Ping  
```
var img=new Image();  
img.onload=img.onerror=function(){
... ...
}
img.src="url?name=value";
```
请求数据通过查询字符串的形式发送，响应可以是任意内容，通常是像素图或204响应。  
图像Ping最常用于跟踪用户点击页面或动态广告曝光次数。  
缺点：  
只能发送GET请求；  
无法访问服务器的响应文本，只能用于浏览器与服务器间的单向通信。  
4. Jsonp  
```
var script=document.createElement("script");
script.src="url?callback=handleResponse";
document.body.insertBefore(script,document.body.firstChild);  
```
JSONP由两部分组成：回调函数和数据  
回调函数是接收到响应时应该在页面中调用的函数，其名字一般在请求中指定。  
数据是传入回调函数中的JSON数据。  
优点：  
能够直接访问响应文本，可用于浏览器与服务器间的双向通信。  
缺点：  
JSONP从其他域中加载代码执行，其他域可能不安全；  
难以确定JSONP请求是否失败。  
5. Comet  
Comet可实现服务器向浏览器推送数据。  
Comet是实现方式：长轮询和流  
短轮询即浏览器定时向服务器发送请求，看有没有数据更新。  
长轮询即浏览器向服务器发送一个请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据后，浏览器关闭连接，随即又向服务器发起一个新请求。其优点是所有浏览器都支持，使用XHR对象和setTimeout()即可实现。  
流即浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据，页面的整个生命周期内只使用一个HTTP连接。  
6. WebSocket  
WebSocket可在一个单独的持久连接上提供全双工、双向通信。  
WebSocket使用自定义协议，未加密的连接时ws://；加密的链接是wss://。  
```
var webSocket=new WebSocket("ws://");
webSocket.send(message);
webSocket.onmessage=function(event){
var data=event.data;
... ....
}
```
注意：  
必须给WebSocket构造函数传入绝对URL；  
WebSocket可以打开任何站点的连接，是否会与某个域中的页面通信，完全取决于服务器；  
WebSocket只能发送纯文本数据，对于复杂的数据结构，在发送之前必须进行序列化JSON.stringify(message))。  
优点：  
在客户端和服务器之间发送非常少的数据，减少字节开销。  

## 新窗口打开网页，用到以下哪个值（_blank）。

在html中通过\<a>标签打开一个链接，通过 \<a> 标签的 target 属性规定在何处打开链接文档。  
如果在标签\<a>中写入target属性，则浏览器会根据target的属性值去打开与其命名或名称相符的 框架\<frame>或者窗口.  
在target中还存在四个保留的属性值如下，  
属性值

| 值		| 描述								|
|:-:		| :-:								|
|_blank		|在新窗口中打开被链接文档。			|
|_self		|默认。在相同的框架中打开被链接文档。	|
|_parent	|在父框架集中打开被链接文档。			|
|_top		|在整个窗口中打开被链接文档。			|
|framename	|在指定的框架中打开被链接文档。			|


## 说一下异步加载js的方法有哪几种
defer：只支持IE如果您的脚本不会改变文档的内容，可将defer属性加入到&lt;script&gt;标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。   
async，HTML5属性仅适用于外部脚本，并且如果在IE中，同时存在defer和async，那么defer的优先级比较高，脚本将在页面完成时执行。 创建script标签，插入到DOM中

1. 给script标签添加async或defer属性
2. js构造script标签在需要时加载
3. ajax获取js内容，构造script标签或直接eval

## 说一下iframe
iframe也称作嵌入式框架，嵌入式框架和框架网页类似，它可以把一个网页的框架和内容嵌入在现有的网页中。

缺点：
1. iframe会阻塞主页面的onload事件；  
2. iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。，会产生很多页面，不容易管理。  
3. iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下 、左右滚动条，会分散访问者的注意力，用户体验度差。  
4. 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化（SEO）。  
5. 很多的移动设备无法完全显示框架，设备兼容性差。  
6. iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。  

## HTML \<textarea\> 标签

\<textarea\>标签定义多行的文本输入控件。

文本区中可容纳无限数量的文本，其中的文本的默认字体是等宽字体（通常是 Courier）。

可以通过 cols 和 rows 属性来规定 textarea 的尺寸，不过更好的办法是使用 CSS 的 height 和 width 属性。
注释：在文本输入区内的文本行间，用 "%OD%OA" （回车/换行）进行分隔。

|属性	|值	|描述												|
|:-:|:-:|:-|
|autofocus	|autofocus	|规定在页面加载后文本区域自动获得焦点。		|
|cols	|number	|规定文本区内的可见宽度。							|
|disabled	|disabled	|规定禁用该文本区。						|
|form	|form_id	|规定文本区域所属的一个或多个表单。				|
|maxlength	|number	|规定文本区域的最大字符数。					|
|name	|name_of_textarea	|规定文本区的名称。					|
|placeholder	|text	|规定描述文本区域预期值的简短提示。			|
|readonly	|readonly	|规定文本区为只读。						|
|required	|required	|规定文本区域是必填的。					|
|rows	|number	|规定文本区内的可见行数。							|
|wrap	|hard  soft		|规定当在表单中提交时，文本区域中的文本如何换行。|

## 重绘和回流（重排）

浏览器：
构建dom树
加载渲染树（CSS样式）
绝对定位
渲染

改变颜色等东西会触发重绘
改变尺寸位置等会触发回流，然后重绘
重绘不一定会回流，回流一定会触发重绘
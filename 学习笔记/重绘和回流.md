# 回流和重绘
## 浏览器的渲染过程
本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘。
![](https://gitee.com/thonger/img/raw/master/img/20200930103521.png)
从上面这个图上，我们可以看到，浏览器渲染过程如下:  
1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)
3. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小)
4. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. Display:将像素发送给GPU，展示在页面上。(这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而 **css3硬件加速的原理则是新建合成层** ，)渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。

## 生成渲染树
![](https://gitee.com/thonger/img/raw/master/img/20200930103616.png)
为了构建渲染树，浏览器主要完成了以下工作:  
1. 从DOM树的根节点开始遍历每个可见节点。
2. 对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。
3. 根据每个可见节点以及其对应的样式，组合生成渲染树。第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括:  
* —些不会渲染输出的节点，比如script、meta、link等。
* 一些通过css进行隐藏的节点。比如display.none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。  

**注意:渲染树只包含可见的节点**

## 回流
前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。  
为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示:



~~~html
<! DOCTYPE html>
<html>

  <head>
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Critial Path: Hello world !</title>
  </head>

  <body>

	<div style="width: 50%">
		<div style="width: 50%">Hello world!</div>
	</div>
  </ body>
</html>
~~~



我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。  
而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。(如下图)
![](https://gitee.com/thonger/img/raw/master/img/20200930104538.png)
## 重绘
最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。  
知道了浏览器的渲染过程后，何时会发生回流重绘。

## 什么时候会发生回流和重绘
我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况:
添加或删除可见的DOM元素  
* 元素的位置发生变化
* 元素的尺寸发生变化(包括外边距、内边框、边框大小、高度和宽度等)
* 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
* 页面一开始渲染的时候（这肯定避免不了)
* 浏览器的窗口尺寸变化(因为回流是根据视口的大小来计算元素的位置和大小的)  

注意:回流—定会触发重绘，而重绘不—定会回流根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，  
比如，滚动条出现的时候或者修改了根节点。


## 浏览器的优化机制
现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达
到了一个阈值，才清空队列。但是!当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问
以下属性或者使用以下方法:

* offsetTop、offsetLeft、offsetWidth、offsetHeight
* scrollTop、scrollLeft、scrollWidth、scrollHeight
* clientTop、clientLeft、clientWidth、clientHeight
* getComputedStyle)
* getBoundingClientRect

以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的
值。因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使
用它们，最好将值缓存起来。

